const express = require('express');
const router = express.Router();
const mongoose = require('mongoose');
const Subscription = require('../models/Subscription');
const User = require('../models/User'); // Th√™m model User
const jwt = require('jsonwebtoken');
const stripe = require('stripe')(process.env.STRIPE_SECRET_KEY);

const authMiddleware = (req, res, next) => {
  const token = req.headers.authorization?.split(' ')[1];
  if (!token) return res.status(401).json({ message: 'Kh√¥ng c√≥ token' });
  try {
    const decoded = jwt.verify(token, process.env.JWT_SECRET);
    console.log('üîç Decoded user:', decoded);
    req.user = decoded;
    next();
  } catch (error) {
    console.error('‚ùå L·ªói authMiddleware:', error.message, error.stack);
    res.status(401).json({ message: 'Token kh√¥ng h·ª£p l·ªá' });
  }
};

// L·∫•y th√¥ng tin subscription
router.get('/', authMiddleware, async (req, res) => {
  try {
    const subscription = await Subscription.findOne({ userId: new mongoose.Types.ObjectId(req.user.id) });
    if (!subscription) return res.status(200).json({ plan: 'free' });
    res.status(200).json({
      plan: subscription.plan,
      status: subscription.status,
      startDate: subscription.startDate,
      endDate: subscription.endDate,
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi l·∫•y subscription:', error.message, error.stack);
    res.status(500).json({ message: 'L·ªói m√°y ch·ªß khi l·∫•y th√¥ng tin subscription' });
  }
});

// N√¢ng c·∫•p g√≥i subscription qua Stripe
router.post('/upgrade', authMiddleware, async (req, res) => {
  const { plan, paymentMethodId } = req.body;
  console.log('üì° Nh·∫≠n y√™u c·∫ßu upgrade:', { plan, paymentMethodId });

  // Ch·ªâ cho ph√©p n√¢ng c·∫•p l√™n g√≥i "pro"
  if (plan !== 'pro') {
    return res.status(400).json({ message: 'G√≥i kh√¥ng h·ª£p l·ªá. Ch·ªâ h·ªó tr·ª£ n√¢ng c·∫•p l√™n "pro"' });
  }

  if (!paymentMethodId) {
    return res.status(400).json({ message: 'Thi·∫øu paymentMethodId' });
  }

  try {
    // Chuy·ªÉn ƒë·ªïi userId th√†nh ObjectId
    const userId = new mongoose.Types.ObjectId(req.user.id);
    console.log('üîç User ID (ObjectId):', userId);

    let subscription = await Subscription.findOne({ userId });
    let customer;

    // T·∫°o ho·∫∑c l·∫•y customer t·ª´ Stripe
    if (subscription && subscription.stripeCustomerId) {
      try {
        customer = await stripe.customers.retrieve(subscription.stripeCustomerId);
        console.log('üîç Customer hi·ªán c√≥:', customer.id);
      } catch (error) {
        console.error('‚ùå Customer kh√¥ng t·ªìn t·∫°i, t·∫°o customer m·ªõi:', error.message);
        customer = await stripe.customers.create({
          email: req.user.email || 'default@example.com',
          metadata: { userId: req.user.id },
        });
        console.log('‚úÖ T·∫°o customer m·ªõi:', customer.id);
        subscription.stripeCustomerId = customer.id;
      }
    } else {
      customer = await stripe.customers.create({
        email: req.user.email || 'default@example.com',
        metadata: { userId: req.user.id },
      });
      console.log('‚úÖ T·∫°o customer m·ªõi:', customer.id);
    }

    // G·∫Øn payment method v√†o customer
    await stripe.paymentMethods.attach(paymentMethodId, { customer: customer.id });
    console.log('‚úÖ ƒê√£ g·∫Øn payment method:', paymentMethodId);

    // S·ª≠ d·ª•ng priceId c·ªßa g√≥i "pro" duy nh·∫•t
    const priceId = 'price_1R6SKtJ0EYLbnLTicD7AMwRk';
    console.log('üì¶ Price ID:', priceId);

    // T·∫°o subscription tr√™n Stripe
    const stripeSubscription = await stripe.subscriptions.create({
      customer: customer.id,
      items: [{ price: priceId }],
      default_payment_method: paymentMethodId,
      payment_behavior: 'allow_incomplete',
    });
    console.log('‚úÖ T·∫°o subscription tr√™n Stripe:', stripeSubscription.id);

    // C·∫≠p nh·∫≠t ho·∫∑c t·∫°o m·ªõi subscription trong database
    if (subscription) {
      subscription.plan = plan;
      subscription.status = 'active';
      subscription.stripeCustomerId = customer.id;
      subscription.stripeSubscriptionId = stripeSubscription.id;
    } else {
      subscription = new Subscription({
        userId,
        plan,
        status: 'active',
        stripeCustomerId: customer.id,
        stripeSubscriptionId: stripeSubscription.id,
        startDate: new Date(),
      });
    }

    await subscription.save();
    console.log('‚úÖ L∆∞u subscription v√†o DB:', subscription._id);

    // C·∫≠p nh·∫≠t plan trong users
    const user = await User.findById(userId);
    if (user) {
      user.plan = plan;
      await user.save();
      console.log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t plan trong users:', { userId: user._id, plan: user.plan });
    } else {
      console.warn('‚ö† Kh√¥ng t√¨m th·∫•y user ƒë·ªÉ c·∫≠p nh·∫≠t plan:', userId);
    }

    res.status(200).json({
      plan: subscription.plan,
      status: subscription.status,
      startDate: subscription.startDate,
      stripeSubscriptionId: stripeSubscription.id,
    });
  } catch (error) {
    console.error('‚ùå L·ªói khi n√¢ng c·∫•p subscription:', error.message, error.stack);
    res.status(500).json({ message: 'L·ªói m√°y ch·ªß khi n√¢ng c·∫•p subscription: ' + error.message });
  }
});

// H·ªßy subscription
router.post('/cancel', authMiddleware, async (req, res) => {
  try {
    const userId = new mongoose.Types.ObjectId(req.user.id);
    console.log('üì° Nh·∫≠n y√™u c·∫ßu h·ªßy subscription t·ª´ user:', userId);

    const subscription = await Subscription.findOne({ userId });
    if (!subscription) {
      return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y subscription' });
    }

    // H·ªßy subscription tr√™n Stripe
    if (subscription.stripeSubscriptionId) {
      const stripeSubscription = await stripe.subscriptions.cancel(subscription.stripeSubscriptionId);
      console.log('‚úÖ ƒê√£ h·ªßy subscription tr√™n Stripe:', stripeSubscription.id);
    }

    // C·∫≠p nh·∫≠t tr·∫°ng th√°i subscription trong database
    subscription.status = 'cancelled';
    subscription.endDate = new Date();
    await subscription.save();
    console.log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t subscription trong DB:', subscription._id);

    // C·∫≠p nh·∫≠t plan trong users v·ªÅ free
    const user = await User.findById(userId);
    if (user) {
      user.plan = 'free';
      await user.save();
      console.log('‚úÖ ƒê√£ c·∫≠p nh·∫≠t plan trong users v·ªÅ free:', { userId: user._id, plan: user.plan });
    } else {
      console.warn('‚ö† Kh√¥ng t√¨m th·∫•y user ƒë·ªÉ c·∫≠p nh·∫≠t plan:', userId);
    }

    res.status(200).json({ message: 'H·ªßy subscription th√†nh c√¥ng', plan: 'free' });
  } catch (error) {
    console.error('‚ùå L·ªói khi h·ªßy subscription:', error.message, error.stack);
    res.status(500).json({ message: 'L·ªói m√°y ch·ªß khi h·ªßy subscription: ' + error.message });
  }
});

// T·∫°o PaymentIntent cho thanh to√°n m·ªôt l·∫ßn (n·∫øu d√πng Stripe Elements)
router.post('/create-payment-intent', authMiddleware, async (req, res) => {
  const { plan } = req.body;
  let amount = 0;
  // Ch·ªâ cho ph√©p g√≥i "pro"
  if (plan === 'pro') amount = 1000 * 20; // $20
  else return res.status(400).json({ message: 'G√≥i kh√¥ng h·ª£p l·ªá. Ch·ªâ h·ªó tr·ª£ thanh to√°n cho g√≥i "pro"' });

  try {
    const paymentIntent = await stripe.paymentIntents.create({
      amount,
      currency: 'usd',
      metadata: { userId: req.user.id, plan },
    });
    res.status(200).json({ clientSecret: paymentIntent.client_secret });
  } catch (error) {
    res.status(500).json({ message: 'L·ªói t·∫°o PaymentIntent', error: error.message });
  }
});

// Th√™m route activate cho thanh to√°n m·ªôt l·∫ßn
router.post('/activate', authMiddleware, async (req, res) => {
  try {
    const { plan } = req.body;
    if (plan !== 'pro') {
      return res.status(400).json({ message: 'Ch·ªâ h·ªó tr·ª£ n√¢ng c·∫•p l√™n g√≥i pro.' });
    }
    const userId = new mongoose.Types.ObjectId(req.user.id);
    // C·∫≠p nh·∫≠t user
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y user' });
    user.plan = 'pro';
    await user.save();
    // C·∫≠p nh·∫≠t ho·∫∑c t·∫°o subscription
    let subscription = await Subscription.findOne({ userId });
    if (subscription) {
      subscription.plan = 'pro';
      subscription.status = 'active';
      subscription.startDate = new Date();
      subscription.endDate = null;
      await subscription.save();
    } else {
      subscription = new Subscription({
        userId,
        plan: 'pro',
        status: 'active',
        startDate: new Date(),
      });
      await subscription.save();
    }
    res.status(200).json({ message: 'K√≠ch ho·∫°t g√≥i pro th√†nh c√¥ng', plan: 'pro' });
  } catch (error) {
    console.error('‚ùå L·ªói khi activate subscription:', error.message, error.stack);
    res.status(500).json({ message: 'L·ªói m√°y ch·ªß khi activate subscription: ' + error.message });
  }
});

// T·∫°o Stripe Checkout Session cho thanh to√°n m·ªôt l·∫ßn
router.post('/create-checkout-session', authMiddleware, async (req, res) => {
  const { plan } = req.body;
  if (plan !== 'pro') {
    return res.status(400).json({ message: 'Ch·ªâ h·ªó tr·ª£ n√¢ng c·∫•p l√™n g√≥i pro.' });
  }
  try {
    const session = await stripe.checkout.sessions.create({
      payment_method_types: ['card'],
      mode: 'payment',
      line_items: [
        {
          price_data: {
            currency: 'usd',
            product_data: { name: 'G√≥i Pro - Qu·∫£n l√Ω t√†i ch√≠nh' },
            unit_amount: 2000 * 100, // $20.00
          },
          quantity: 1,
        },
      ],
      customer_email: req.user.email,
      success_url: `${process.env.CLIENT_URL}/payment-success?session_id={CHECKOUT_SESSION_ID}`,
      cancel_url: `${process.env.CLIENT_URL}/payment-cancel`,
      metadata: { userId: req.user.id, plan: 'pro' },
    });
    res.json({ url: session.url });
  } catch (error) {
    console.error('‚ùå L·ªói t·∫°o checkout session:', error);
    res.status(500).json({ message: 'L·ªói m√°y ch·ªß khi t·∫°o checkout session' });
  }
});

// X√°c nh·∫≠n thanh to√°n th√†nh c√¥ng t·ª´ Stripe Checkout
router.post('/confirm-checkout', authMiddleware, async (req, res) => {
  try {
    const { sessionId } = req.body;
    if (!sessionId) return res.status(400).json({ message: 'Thi·∫øu sessionId' });
    const session = await stripe.checkout.sessions.retrieve(sessionId);
    if (session.payment_status !== 'paid') {
      return res.status(400).json({ message: 'Thanh to√°n ch∆∞a ho√†n t·∫•t!' });
    }
    const userId = new mongoose.Types.ObjectId(req.user.id);
    // C·∫≠p nh·∫≠t user
    const user = await User.findById(userId);
    if (!user) return res.status(404).json({ message: 'Kh√¥ng t√¨m th·∫•y user' });
    user.plan = 'pro';
    await user.save();
    // C·∫≠p nh·∫≠t ho·∫∑c t·∫°o subscription
    let subscription = await Subscription.findOne({ userId });
    if (subscription) {
      subscription.plan = 'pro';
      subscription.status = 'active';
      subscription.startDate = new Date();
      subscription.endDate = null;
      await subscription.save();
    } else {
      subscription = new Subscription({
        userId,
        plan: 'pro',
        status: 'active',
        startDate: new Date(),
      });
      await subscription.save();
    }
    res.status(200).json({ message: 'ƒê√£ x√°c nh·∫≠n thanh to√°n v√† n√¢ng c·∫•p g√≥i pro!' });
  } catch (error) {
    console.error('‚ùå L·ªói khi x√°c nh·∫≠n checkout:', error.message, error.stack);
    res.status(500).json({ message: 'L·ªói m√°y ch·ªß khi x√°c nh·∫≠n checkout: ' + error.message });
  }
});

module.exports = router;